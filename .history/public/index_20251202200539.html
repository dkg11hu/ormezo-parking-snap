<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#ffffff" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="msapplication-TileColor" content="#ffffff" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="apple-touch-icon" sizes="64x64" href="/icons/favicon-64.png" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <title>P+R Parkoló Foglaltság</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div>
        <h1>P+R Parkoló Foglaltság</h1>
        <div class="meta" id="last-updated">Frissítve: —</div>
      </div>

      <div id="controls">
        <button id="refreshBtn" aria-label="Frissítés">Frissít</button>
        <div class="status" id="status" aria-hidden="true">—</div>
      </div>
    </header>

    <!-- overall free-space bar -->
    <div class="overall-status" aria-live="polite" role="region" aria-label="Szabad helyek összesítve">
      <div class="overall-header">
        <strong id="overall-title" class="overall-title">Szabad helyek összesítve</strong>
        <div id="overall-percent" class="overall-percent">—</div>
      </div>

      <div id="status-track"
           class="status-track"
           role="progressbar"
           aria-valuemin="0"
           aria-valuemax="100"
           aria-valuenow="0"
           aria-labelledby="overall-title">
        <div id="status-fill" class="status-fill"></div>
      </div>

      <div id="overall-note" class="overall-note" aria-hidden="false"></div>
    </div>

    <main id="list" aria-live="polite">
      <!-- cards injected here -->
    </main>

    <footer>
      Az oldal automatikusan frissül. Ha nem látsz friss adatot, nyomd meg a Frissít gombot.
    </footer>
  </div>

  <script>
    // Configuration
    const LOCAL_JSON = '/parking-status.json';
    // If you open index.html via file:// during development, set FALLBACK_URL to your deployed endpoint:
    // const FALLBACK_URL = 'https://ormezo-parking-snap.onrender.com/parking-status.json';
    const FALLBACK_URL = ''; // set to deployed URL if needed
    const POLL_INTERVAL_MS = 30_000;      // poll every 30s
    const FALLBACK_REFRESH_MS = 300_000;  // 5 minutes fallback

    // DOM refs
    const list = document.getElementById('list');
    const lastUpdated = document.getElementById('last-updated');
    const status = document.getElementById('status');
    const refreshBtn = document.getElementById('refreshBtn');
    const overallPercent = document.getElementById('overall-percent');
    const statusFill = document.getElementById('status-fill');
    const overallNote = document.getElementById('overall-note');
    const statusTrack = document.getElementById('status-track');

    // State
    let lastSignature = null;
    let pollTimer = null;
    let consecutivePollErrors = 0;

    // Helpers

    // Normalize source timestamps without forcing UTC 'Z' suffix.
    // If the source provides "YYYY-MM-DD HH:MM:SS", convert to "YYYY-MM-DDTHH:MM:SS"
    // but do NOT append 'Z' because the source timestamp is likely local or unspecified.
    function normalizeUpdated(ts) {
      if (!ts) return '';
      if (ts.includes('T') || ts.endsWith('Z')) return ts;
      return ts.replace(' ', 'T');
    }

    // Format a timestamp string for display. Accepts ISO-like or "YYYY-MM-DDTHH:MM:SS".
    // If parsing fails, return the original string.
    function formatForDisplay(ts) {
      if (!ts) return '';
      try {
        const d = new Date(ts);
        if (isNaN(d.getTime())) return ts;
        return d.toLocaleString();
      } catch (e) {
        return ts;
      }
    }

    function createCard(item) {
      const freePct = item.total ? (item.free / item.total * 100) : 0;
      const card = document.createElement('article');
      card.className = 'card';
      card.setAttribute('role','article');

      const left = document.createElement('div');
      left.className = 'left';

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = item.label;

      const barWrap = document.createElement('div');
      barWrap.className = 'bar-wrap';
      const bar = document.createElement('div');
      bar.className = 'bar';
      const fill = document.createElement('div');
      fill.className = 'fill';
      fill.style.width = freePct + '%';

      const pctText = document.createElement('div');
      pctText.className = 'pct';
      pctText.textContent = freePct.toFixed(1) + '%';

      bar.appendChild(fill);
      barWrap.appendChild(bar);
      barWrap.appendChild(pctText);

      left.appendChild(label);
      left.appendChild(barWrap);

      const numbers = document.createElement('div');
      numbers.className = 'numbers';
      const count = document.createElement('div');
      count.className = 'count';
      count.textContent = item.free;
      count.setAttribute('aria-label', item.free + ' szabad hely');
      const total = document.createElement('div');
      total.className = 'total';
      total.textContent = '/' + item.total;

      const ts = document.createElement('div');
      ts.className = 'timestamp';
      // Show both source timestamp and fetched_at if available
      const srcRaw = item.source_updated || item.updated || null;
      const src = srcRaw ? formatForDisplay(normalizeUpdated(srcRaw)) : null;
      const fetchedRaw = item.fetched_at || item.fetchedAt || null;
      const fetched = fetchedRaw ? formatForDisplay(normalizeUpdated(fetchedRaw)) : null;

      if (src && fetched) {
        ts.textContent = `Forrás: ${src} • Rögzítve: ${fetched}`;
      } else if (src) {
        ts.textContent = `Forrás: ${src}`;
      } else if (fetched) {
        ts.textContent = `Rögzítve: ${fetched}`;
      } else {
        ts.textContent = '';
      }

      numbers.appendChild(count);
      numbers.appendChild(total);
      numbers.appendChild(ts);

      card.appendChild(left);
      card.appendChild(numbers);

      return card;
    }

    function makeSignature(json) {
      if (!Array.isArray(json)) return '';
      return json
        .slice()
        .map(it => ({
          id: it.id || '',
          free: Number(it.free) || 0,
          total: Number(it.total) || 0,
          // include normalized source timestamp so signature changes when source timestamp changes
          source_updated: normalizeUpdated(it.source_updated || it.updated || '')
        }))
        .sort((a,b) => (a.id || '').localeCompare(b.id || ''))
        .map(it => `${it.id}|${it.free}|${it.total}|${it.source_updated || ''}`)
        .join('||');
    }

    function render(data) {
      // normalize fields for display: preserve source_updated, use fetched_at if present
      const normalized = data.map(it => ({
        ...it,
        source_updated: it.source_updated || it.updated || null,
        fetched_at: it.fetched_at || it.fetchedAt || null
      }));
      normalized.sort((a,b) => (b.free||0) - (a.free||0));
      list.innerHTML = '';
      normalized.forEach(it => list.appendChild(createCard(it)));
      // Use fetched_at of the first item as the "last updated" server time if present
      const latestFetched = normalized.find(it => it.fetched_at)?.fetched_at || null;
      lastUpdated.textContent = 'Frissítve: ' + (latestFetched ? formatForDisplay(normalizeUpdated(latestFetched)) : new Date().toLocaleString());
      updateOverallStatus(normalized);
    }

    function updateOverallStatus(data) {
      if (!Array.isArray(data) || data.length === 0) {
        overallPercent.textContent = '—';
        statusFill.style.width = '0%';
        overallNote.textContent = '';
        if (statusTrack) statusTrack.setAttribute('aria-valuenow', '0');
        return;
      }

      let totalSpaces = 0, totalFree = 0;
      for (const p of data) {
        totalSpaces += Number(p.total) || 0;
        totalFree += Number(p.free) || 0;
      }

      const percentFree = totalSpaces > 0 ? Math.round((totalFree / totalSpaces) * 100) : 0;

      overallPercent.textContent = percentFree + '%';
      statusFill.style.width = percentFree + '%';
      if (statusTrack) statusTrack.setAttribute('aria-valuenow', String(percentFree));

      const latest = data.reduce((a,b) => (a && a > (b.fetched_at||b.source_updated||'') ? a : (b.fetched_at||b.source_updated||'')), '');
      overallNote.textContent = `Összes: ${totalSpaces} • Szabad: ${totalFree} • Foglalt: ${Math.max(0, totalSpaces - totalFree)} • Utolsó: ${latest ? formatForDisplay(normalizeUpdated(latest)) : 'ismeretlen'}`;
    }

    // --- robust fetch with timeout and optional fallback ---
    function fetchWithTimeout(resource, options = {}) {
      const { timeout = 8000 } = options;
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      return fetch(resource, { ...options, signal: controller.signal })
        .finally(() => clearTimeout(id));
    }

    async function fetchJsonRaw(url) {
      try {
        const res = await fetchWithTimeout(url, { cache: 'no-store', timeout: 8000 });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const raw = await res.text();
        let json;
        try { json = JSON.parse(raw); } catch (e) { throw new Error('JSON parse error'); }
        return { raw, json };
      } catch (err) {
        err.message = err.message || 'Failed to fetch';
        throw err;
      }
    }

    // Improved initial loader that falls back to remote if local fails (useful when opening file://)
    async function loadInitialFromLocal() {
      status.textContent = 'Betöltés…';
      refreshBtn.disabled = true;
      try {
        // try local relative path first
        try {
          const { raw, json } = await fetchJsonRaw(LOCAL_JSON);
          lastSignature = makeSignature(json);
          if (!Array.isArray(json)) throw new Error('Váratlan formátum');
          render(json);
          status.textContent = 'OK';
          return;
        } catch (localErr) {
          console.warn('local fetch failed:', localErr.message);
          // if we have a fallback remote URL, try it
          if (FALLBACK_URL) {
            try {
              const { raw, json } = await fetchJsonRaw(FALLBACK_URL + '?t=' + Date.now());
              lastSignature = makeSignature(json);
              if (!Array.isArray(json)) throw new Error('Váratlan formátum (fallback)');
              render(json);
              status.textContent = 'OK (fallback)';
              return;
            } catch (remoteErr) {
              console.warn('fallback fetch failed:', remoteErr.message);
              throw remoteErr;
            }
          }
          throw localErr;
        }
      } catch (err) {
        console.error('initial load error', err);
        status.textContent = 'Hiba';
      } finally {
        refreshBtn.disabled = false;
      }
    }

    // Improved poll that tolerates transient failures and avoids noisy logs
    async function pollLocalJson() {
      try {
        const { raw, json } = await fetchJsonRaw(LOCAL_JSON + '?t=' + Date.now());
        const sig = makeSignature(json);
        if (sig !== lastSignature) {
          lastSignature = sig;
          if (Array.isArray(json)) {
            render(json);
            status.textContent = 'OK';
          } else {
            console.warn('polled JSON not array, skipping render');
          }
        }
        consecutivePollErrors = 0;
      } catch (err) {
        consecutivePollErrors++;
        if (consecutivePollErrors <= 3) console.error('poll error', err);
        status.textContent = 'Hiba';
        // if many consecutive failures and we have a fallback, try fallback once
        if (consecutivePollErrors === 3 && FALLBACK_URL) {
          try {
            const { raw, json } = await fetchJsonRaw(FALLBACK_URL + '?t=' + Date.now());
            const sig = makeSignature(json);
            if (sig !== lastSignature) {
              lastSignature = sig;
              if (Array.isArray(json)) {
                render(json);
                status.textContent = 'OK (fallback)';
              }
            }
            consecutivePollErrors = 0;
          } catch (fallbackErr) {
            console.warn('fallback poll failed', fallbackErr.message);
          }
        }
      }
    }

    function startPolling() {
      if (pollTimer) return;
      pollLocalJson().catch(()=>{});
      pollTimer = setInterval(pollLocalJson, POLL_INTERVAL_MS);
    }

    async function manualRefresh() {
      status.textContent = 'Frissítés…';
      refreshBtn.disabled = true;
      try {
        const { raw, json } = await fetchJsonRaw(LOCAL_JSON + '?t=' + Date.now());
        lastSignature = makeSignature(json);
        if (Array.isArray(json)) {
          render(json);
          status.textContent = 'OK';
        } else {
          status.textContent = 'Hiba';
        }
      } catch (err) {
        console.error('manual refresh error', err);
        // try fallback once on manual refresh if configured
        if (FALLBACK_URL) {
          try {
            const { raw, json } = await fetchJsonRaw(FALLBACK_URL + '?t=' + Date.now());
            lastSignature = makeSignature(json);
            if (Array.isArray(json)) {
              render(json);
              status.textContent = 'OK (fallback)';
            } else {
              status.textContent = 'Hiba';
            }
          } catch (fallbackErr) {
            console.error('manual fallback error', fallbackErr);
            status.textContent = 'Hiba';
          }
        } else {
          status.textContent = 'Hiba';
        }
      } finally {
        refreshBtn.disabled = false;
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await loadInitialFromLocal();
      startPolling();
      setInterval(manualRefresh, FALLBACK_REFRESH_MS);
    });

    refreshBtn.addEventListener('click', manualRefresh);

    // touch pull-to-refresh
    let touchStartY = 0;
    window.addEventListener('touchstart', e => { if (window.scrollY === 0) touchStartY = e.touches[0].clientY; });
    window.addEventListener('touchend', e => {
      const dy = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY - touchStartY : 0;
      if (dy > 80) manualRefresh();
    });
  </script>
</body>
</html>