<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#ffffff" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="msapplication-TileColor" content="#ffffff" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="apple-touch-icon" sizes="64x64" href="/icons/favicon-64.png" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <title>P+R Parkoló Foglaltság</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div>
        <h1>P+R Parkoló Foglaltság</h1>
        <div class="meta" id="last-updated">Frissítve: —</div>
      </div>

      <div id="controls">
        <button id="refreshBtn" aria-label="Frissítés">Frissít</button>
        <div class="status" id="status" aria-hidden="true">—</div>
      </div>
    </header>

    <!-- overall free-space bar -->
    <div class="overall-status" aria-live="polite" role="region" aria-label="Szabad helyek összesítve">
      <div class="overall-header">
        <strong id="overall-title" class="overall-title">Szabad helyek összesítve</strong>
        <div id="overall-percent" class="overall-percent">—</div>
      </div>

      <div id="status-track"
           class="status-track"
           role="progressbar"
           aria-valuemin="0"
           aria-valuemax="100"
           aria-valuenow="0"
           aria-labelledby="overall-title">
        <div id="status-fill" class="status-fill"></div>
      </div>

      <div id="overall-note" class="overall-note" aria-hidden="false"></div>
    </div>

    <main id="list" aria-live="polite">
      <!-- cards injected here -->
    </main>

    <footer>
      Az oldal automatikusan frissül. Ha nem látsz friss adatot, nyomd meg a Frissít gombot.
    </footer>
  </div>

  <script>
    // Configuration
    const LOCAL_JSON = '/parking-status.json';
    const FALLBACK_URL = ''; // set to deployed URL if needed
    const POLL_INTERVAL_MS = 30_000;
    const FALLBACK_REFRESH_MS = 300_000;

    // DOM refs
    const list = document.getElementById('list');
    const lastUpdated = document.getElementById('last-updated');
    const status = document.getElementById('status');
    const refreshBtn = document.getElementById('refreshBtn');
    const overallPercent = document.getElementById('overall-percent');
    const statusFill = document.getElementById('status-fill');
    const overallNote = document.getElementById('overall-note');
    const statusTrack = document.getElementById('status-track');

    // State
    let lastSignature = null;
    let pollTimer = null;
    let consecutivePollErrors = 0;

    // Helpers
    function normalizeUpdated(ts) {
      if (!ts) return '';
      if (ts.includes('T') || ts.endsWith('Z')) return ts;
      return ts.replace(' ', 'T');
    }

    function parseToDate(ts) {
      if (!ts) return null;
      const s = normalizeUpdated(ts);
      const d = new Date(s);
      if (isNaN(d.getTime())) return null;
      return d;
    }

    function timeDiffString(fromDate, toDate) {
      if (!fromDate || !toDate) return '';
      let diff = Math.floor((fromDate.getTime() - toDate.getTime()) / 1000); // seconds
      const absDiff = Math.abs(diff);
      if (absDiff < 10) return 'most';
      if (absDiff < 60) return `${absDiff} mp`;
      const minutes = Math.floor(absDiff / 60);
      if (minutes < 60) return `${minutes} perc`;
      const hours = Math.floor(minutes / 60);
      const remMinutes = minutes % 60;
      if (hours < 24) return remMinutes ? `${hours} óra ${remMinutes} perc` : `${hours} óra`;
      const days = Math.floor(hours / 24);
      if (days < 30) return `${days} nap`;
      const months = Math.floor(days / 30);
      if (months < 12) return `${months} hó`;
      const years = Math.floor(months / 12);
      return `${years} év`;
    }

    // Convert the neutral diff string into Hungarian "X perccel ezelőtt" style.
    function hungarianAgo(diffStr) {
      if (!diffStr) return '';
      if (diffStr === 'most') return 'most';
      // seconds -> "X másodperccel ezelőtt"
      if (diffStr.endsWith(' mp')) {
        const n = diffStr.replace(' mp', '');
        return `${n} másodperccel ezelőtt`;
      }
      // minutes -> "X perccel ezelőtt"
      if (diffStr.endsWith(' perc')) {
        const n = diffStr.replace(' perc', '');
        return `${n} perccel ezelőtt`;
      }
      // hours with optional minutes -> "X órával Y perccel ezelőtt" or "X órával ezelőtt"
      if (diffStr.includes(' óra')) {
        const parts = diffStr.split(' óra');
        const hours = parts[0].trim();
        const rest = parts[1].trim(); // either "" or " Y perc"
        if (!rest) return `${hours} órával ezelőtt`;
        const minutesPart = rest.replace(' ', '').replace('perc','').replace(':','').trim();
        // fallback: if rest contains number of minutes
        const minutesMatch = rest.match(/(\d+)\s*perc/);
        if (minutesMatch) {
          return `${hours} órával ${minutesMatch[1]} perccel ezelőtt`;
        }
        return `${hours} órával ezelőtt`;
      }
      // days/months/years -> append " ezelőtt"
      return `${diffStr} ezelőtt`;
    }

    function formatForDisplay(ts) {
      if (!ts) return '';
      const d = parseToDate(ts);
      if (!d) return ts;
      return d.toLocaleString();
    }

    function createCard(item, refreshTime) {
      const freePct = item.total ? (item.free / item.total * 100) : 0;
      const card = document.createElement('article');
      card.className = 'card';
      card.setAttribute('role','article');

      const left = document.createElement('div');
      left.className = 'left';

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = item.label;

      const barWrap = document.createElement('div');
      barWrap.className = 'bar-wrap';
      const bar = document.createElement('div');
      bar.className = 'bar';
      const fill = document.createElement('div');
      fill.className = 'fill';
      fill.style.width = freePct + '%';

      const pctText = document.createElement('div');
      pctText.className = 'pct';
      pctText.textContent = freePct.toFixed(1) + '%';

      bar.appendChild(fill);
      barWrap.appendChild(bar);
      barWrap.appendChild(pctText);

      left.appendChild(label);
      left.appendChild(barWrap);

      const numbers = document.createElement('div');
      numbers.className = 'numbers';
      const count = document.createElement('div');
      count.className = 'count';
      count.textContent = item.free;
      count.setAttribute('aria-label', item.free + ' szabad hely');
      const total = document.createElement('div');
      total.className = 'total';
      total.textContent = '/' + item.total;

      const ts = document.createElement('div');
      ts.className = 'timestamp';

      // Determine timestamps
      const srcRaw = item.source_updated || item.updated || null;
      const fetchedRaw = item.fetched_at || item.fetchedAt || null;

      // If fetched_at missing, assume it was fetched at refreshTime
      const fetchedDate = parseToDate(fetchedRaw) || refreshTime || new Date();
      const srcDate = parseToDate(srcRaw);

      // Build relative strings
      const now = refreshTime || new Date();
      const diffFetchedSource = srcDate ? timeDiffString(fetchedDate, srcDate) : null;
      const srcRelative = diffFetchedSource ? hungarianAgo(diffFetchedSource) : null;

      // We will NOT show the absolute fetched timestamp in the card (user requested to remove it).
      // Show only the source relative age like "58 perccel ezelőtt".
      ts.textContent = srcRelative ? srcRelative : '';

      numbers.appendChild(count);
      numbers.appendChild(total);
      numbers.appendChild(ts);

      card.appendChild(left);
      card.appendChild(numbers);

      return card;
    }

    function makeSignature(json) {
      if (!Array.isArray(json)) return '';
      return json
        .slice()
        .map(it => ({
          id: it.id || '',
          free: Number(it.free) || 0,
          total: Number(it.total) || 0,
          source_updated: normalizeUpdated(it.source_updated || it.updated || '')
        }))
        .sort((a,b) => (a.id || '').localeCompare(b.id || ''))
        .map(it => `${it.id}|${it.free}|${it.total}|${it.source_updated || ''}`)
        .join('||');
    }

    function render(data) {
      const normalized = data.map(it => ({
        ...it,
        source_updated: it.source_updated || it.updated || null,
        fetched_at: it.fetched_at || it.fetchedAt || null
      }));
      normalized.sort((a,b) => (b.free||0) - (a.free||0));
      list.innerHTML = '';

      // capture refresh time once so all cards compute diffs against the same moment
      const refreshTime = new Date();

      normalized.forEach(it => list.appendChild(createCard(it, refreshTime)));
      // Header "Frissítve" should show the refresh time (server write time)
      lastUpdated.textContent = 'Frissítve: ' + refreshTime.toLocaleString();
      updateOverallStatus(normalized, refreshTime);
    }

    function updateOverallStatus(data, refreshTime) {
      if (!Array.isArray(data) || data.length === 0) {
        overallPercent.textContent = '—';
        statusFill.style.width = '0%';
        overallNote.textContent = '';
        if (statusTrack) statusTrack.setAttribute('aria-valuenow', '0');
        return;
      }

      let totalSpaces = 0, totalFree = 0;
      for (const p of data) {
        totalSpaces += Number(p.total) || 0;
        totalFree += Number(p.free) || 0;
      }

      const percentFree = totalSpaces > 0 ? Math.round((totalFree / totalSpaces) * 100) : 0;

      overallPercent.textContent = percentFree + '%';
      statusFill.style.width = percentFree + '%';
      if (statusTrack) statusTrack.setAttribute('aria-valuenow', String(percentFree));

      // Determine latest fetched_at among items (or fallback to refreshTime)
      let latestFetched = null;
      for (const it of data) {
        const d = parseToDate(it.fetched_at || it.fetchedAt);
        if (d && (!latestFetched || d > latestFetched)) latestFetched = d;
      }
      if (!latestFetched) latestFetched = refreshTime || new Date();

      const latestDisplay = formatForDisplay(latestFetched.toISOString());
      const diff = timeDiffString(refreshTime || new Date(), latestFetched);
      const diffHung = hungarianAgo(diff);

      overallNote.textContent = `Összes: ${totalSpaces} • Szabad: ${totalFree} • Foglalt: ${Math.max(0, totalSpaces - totalFree)} • Utolsó rögzítés: ${latestDisplay} (${diffHung})`;
    }

    // --- robust fetch with timeout and optional fallback ---
    function fetchWithTimeout(resource, options = {}) {
      const { timeout = 8000 } = options;
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      return fetch(resource, { ...options, signal: controller.signal })
        .finally(() => clearTimeout(id));
    }

    async function fetchJsonRaw(url) {
      try {
        const res = await fetchWithTimeout(url, { cache: 'no-store', timeout: 8000 });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const raw = await res.text();
        let json;
        try { json = JSON.parse(raw); } catch (e) { throw new Error('JSON parse error'); }
        return { raw, json };
      } catch (err) {
        err.message = err.message || 'Failed to fetch';
        throw err;
      }
    }

    async function loadInitialFromLocal() {
      status.textContent = 'Betöltés…';
      refreshBtn.disabled = true;
      try {
        try {
          const { raw, json } = await fetchJsonRaw(LOCAL_JSON);
          lastSignature = makeSignature(json);
          if (!Array.isArray(json)) throw new Error('Váratlan formátum');
          render(json);
          status.textContent = 'OK';
          return;
        } catch (localErr) {
          console.warn('local fetch failed:', localErr.message);
          if (FALLBACK_URL) {
            try {
              const { raw, json } = await fetchJsonRaw(FALLBACK_URL + '?t=' + Date.now());
              lastSignature = makeSignature(json);
              if (!Array.isArray(json)) throw new Error('Váratlan formátum (fallback)');
              render(json);
              status.textContent = 'OK (fallback)';
              return;
            } catch (remoteErr) {
              console.warn('fallback fetch failed:', remoteErr.message);
              throw remoteErr;
            }
          }
          throw localErr;
        }
      } catch (err) {
        console.error('initial load error', err);
        status.textContent = 'Hiba';
      } finally {
        refreshBtn.disabled = false;
      }
    }

    async function pollLocalJson() {
      try {
        const { raw, json } = await fetchJsonRaw(LOCAL_JSON + '?t=' + Date.now());
        const sig = makeSignature(json);
        if (sig !== lastSignature) {
          lastSignature = sig;
          if (Array.isArray(json)) {
            render(json);
            status.textContent = 'OK';
          } else {
            console.warn('polled JSON not array, skipping render');
          }
        }
        consecutivePollErrors = 0;
      } catch (err) {
        consecutivePollErrors++;
        if (consecutivePollErrors <= 3) console.error('poll error', err);
        status.textContent = 'Hiba';
        if (consecutivePollErrors === 3 && FALLBACK_URL) {
          try {
            const { raw, json } = await fetchJsonRaw(FALLBACK_URL + '?t=' + Date.now());
            const sig = makeSignature(json);
            if (sig !== lastSignature) {
              lastSignature = sig;
              if (Array.isArray(json)) {
                render(json);
                status.textContent = 'OK (fallback)';
              }
            }
            consecutivePollErrors = 0;
          } catch (fallbackErr) {
            console.warn('fallback poll failed', fallbackErr.message);
          }
        }
      }
    }

    function startPolling() {
      if (pollTimer) return;
      pollLocalJson().catch(()=>{});
      pollTimer = setInterval(pollLocalJson, POLL_INTERVAL_MS);
    }

    async function manualRefresh() {
      status.textContent = 'Frissítés…';
      refreshBtn.disabled = true;
      try {
        const { raw, json } = await fetchJsonRaw(LOCAL_JSON + '?t=' + Date.now());
        lastSignature = makeSignature(json);
        if (Array.isArray(json)) {
          render(json);
          status.textContent = 'OK';
        } else {
          status.textContent = 'Hiba';
        }
      } catch (err) {
        console.error('manual refresh error', err);
        if (FALLBACK_URL) {
          try {
            const { raw, json } = await fetchJsonRaw(FALLBACK_URL + '?t=' + Date.now());
            lastSignature = makeSignature(json);
            if (Array.isArray(json)) {
              render(json);
              status.textContent = 'OK (fallback)';
            } else {
              status.textContent = 'Hiba';
            }
          } catch (fallbackErr) {
            console.error('manual fallback error', fallbackErr);
            status.textContent = 'Hiba';
          }
        } else {
          status.textContent = 'Hiba';
        }
      } finally {
        refreshBtn.disabled = false;
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await loadInitialFromLocal();
      startPolling();
      setInterval(manualRefresh, FALLBACK_REFRESH_MS);
    });

    refreshBtn.addEventListener('click', manualRefresh);

    // touch pull-to-refresh
    let touchStartY = 0;
    window.addEventListener('touchstart', e => { if (window.scrollY === 0) touchStartY = e.touches[0].clientY; });
    window.addEventListener('touchend', e => {
      const dy = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY - touchStartY : 0;
      if (dy > 80) manualRefresh();
    });
  </script>
</body>
</html>
